// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: chatting.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_chatting_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_chatting_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "packet_id.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_chatting_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_chatting_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_chatting_2eproto;
namespace chat {
class ChatBroadcastNoti;
struct ChatBroadcastNotiDefaultTypeInternal;
extern ChatBroadcastNotiDefaultTypeInternal _ChatBroadcastNoti_default_instance_;
class ChatBroadcastReq;
struct ChatBroadcastReqDefaultTypeInternal;
extern ChatBroadcastReqDefaultTypeInternal _ChatBroadcastReq_default_instance_;
class ChatHistoryReq;
struct ChatHistoryReqDefaultTypeInternal;
extern ChatHistoryReqDefaultTypeInternal _ChatHistoryReq_default_instance_;
class ChatHistoryRes;
struct ChatHistoryResDefaultTypeInternal;
extern ChatHistoryResDefaultTypeInternal _ChatHistoryRes_default_instance_;
class ChatJoinReq;
struct ChatJoinReqDefaultTypeInternal;
extern ChatJoinReqDefaultTypeInternal _ChatJoinReq_default_instance_;
class ChatJoinRes;
struct ChatJoinResDefaultTypeInternal;
extern ChatJoinResDefaultTypeInternal _ChatJoinRes_default_instance_;
class ChatMsgInfo;
struct ChatMsgInfoDefaultTypeInternal;
extern ChatMsgInfoDefaultTypeInternal _ChatMsgInfo_default_instance_;
class GuildNicknameChatMsgInfo;
struct GuildNicknameChatMsgInfoDefaultTypeInternal;
extern GuildNicknameChatMsgInfoDefaultTypeInternal _GuildNicknameChatMsgInfo_default_instance_;
class LoginReq;
struct LoginReqDefaultTypeInternal;
extern LoginReqDefaultTypeInternal _LoginReq_default_instance_;
class LoginRes;
struct LoginResDefaultTypeInternal;
extern LoginResDefaultTypeInternal _LoginRes_default_instance_;
class NicknameChatMsgInfo;
struct NicknameChatMsgInfoDefaultTypeInternal;
extern NicknameChatMsgInfoDefaultTypeInternal _NicknameChatMsgInfo_default_instance_;
class PetInfo;
struct PetInfoDefaultTypeInternal;
extern PetInfoDefaultTypeInternal _PetInfo_default_instance_;
class PingReq;
struct PingReqDefaultTypeInternal;
extern PingReqDefaultTypeInternal _PingReq_default_instance_;
class PingRes;
struct PingResDefaultTypeInternal;
extern PingResDefaultTypeInternal _PingRes_default_instance_;
}  // namespace chat
PROTOBUF_NAMESPACE_OPEN
template<> ::chat::ChatBroadcastNoti* Arena::CreateMaybeMessage<::chat::ChatBroadcastNoti>(Arena*);
template<> ::chat::ChatBroadcastReq* Arena::CreateMaybeMessage<::chat::ChatBroadcastReq>(Arena*);
template<> ::chat::ChatHistoryReq* Arena::CreateMaybeMessage<::chat::ChatHistoryReq>(Arena*);
template<> ::chat::ChatHistoryRes* Arena::CreateMaybeMessage<::chat::ChatHistoryRes>(Arena*);
template<> ::chat::ChatJoinReq* Arena::CreateMaybeMessage<::chat::ChatJoinReq>(Arena*);
template<> ::chat::ChatJoinRes* Arena::CreateMaybeMessage<::chat::ChatJoinRes>(Arena*);
template<> ::chat::ChatMsgInfo* Arena::CreateMaybeMessage<::chat::ChatMsgInfo>(Arena*);
template<> ::chat::GuildNicknameChatMsgInfo* Arena::CreateMaybeMessage<::chat::GuildNicknameChatMsgInfo>(Arena*);
template<> ::chat::LoginReq* Arena::CreateMaybeMessage<::chat::LoginReq>(Arena*);
template<> ::chat::LoginRes* Arena::CreateMaybeMessage<::chat::LoginRes>(Arena*);
template<> ::chat::NicknameChatMsgInfo* Arena::CreateMaybeMessage<::chat::NicknameChatMsgInfo>(Arena*);
template<> ::chat::PetInfo* Arena::CreateMaybeMessage<::chat::PetInfo>(Arena*);
template<> ::chat::PingReq* Arena::CreateMaybeMessage<::chat::PingReq>(Arena*);
template<> ::chat::PingRes* Arena::CreateMaybeMessage<::chat::PingRes>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace chat {

enum ChatMsgInfo_AdminType : int {
  ChatMsgInfo_AdminType_User = 0,
  ChatMsgInfo_AdminType_QA = 1,
  ChatMsgInfo_AdminType_Admin = 2,
  ChatMsgInfo_AdminType_ChatMsgInfo_AdminType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ChatMsgInfo_AdminType_ChatMsgInfo_AdminType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ChatMsgInfo_AdminType_IsValid(int value);
constexpr ChatMsgInfo_AdminType ChatMsgInfo_AdminType_AdminType_MIN = ChatMsgInfo_AdminType_User;
constexpr ChatMsgInfo_AdminType ChatMsgInfo_AdminType_AdminType_MAX = ChatMsgInfo_AdminType_Admin;
constexpr int ChatMsgInfo_AdminType_AdminType_ARRAYSIZE = ChatMsgInfo_AdminType_AdminType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ChatMsgInfo_AdminType_descriptor();
template<typename T>
inline const std::string& ChatMsgInfo_AdminType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ChatMsgInfo_AdminType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ChatMsgInfo_AdminType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ChatMsgInfo_AdminType_descriptor(), enum_t_value);
}
inline bool ChatMsgInfo_AdminType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ChatMsgInfo_AdminType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ChatMsgInfo_AdminType>(
    ChatMsgInfo_AdminType_descriptor(), name, value);
}
enum ChatJoinReq_Language : int {
  ChatJoinReq_Language_kKorean = 0,
  ChatJoinReq_Language_kEnglish = 1,
  ChatJoinReq_Language_kFrench = 2,
  ChatJoinReq_Language_kDeutsch = 3,
  ChatJoinReq_Language_kJapanese = 4,
  ChatJoinReq_Language_kThai = 5,
  ChatJoinReq_Language_kChinesesSimple = 6,
  ChatJoinReq_Language_kChinesesTraditional = 7,
  ChatJoinReq_Language_ChatJoinReq_Language_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ChatJoinReq_Language_ChatJoinReq_Language_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ChatJoinReq_Language_IsValid(int value);
constexpr ChatJoinReq_Language ChatJoinReq_Language_Language_MIN = ChatJoinReq_Language_kKorean;
constexpr ChatJoinReq_Language ChatJoinReq_Language_Language_MAX = ChatJoinReq_Language_kChinesesTraditional;
constexpr int ChatJoinReq_Language_Language_ARRAYSIZE = ChatJoinReq_Language_Language_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ChatJoinReq_Language_descriptor();
template<typename T>
inline const std::string& ChatJoinReq_Language_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ChatJoinReq_Language>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ChatJoinReq_Language_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ChatJoinReq_Language_descriptor(), enum_t_value);
}
inline bool ChatJoinReq_Language_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ChatJoinReq_Language* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ChatJoinReq_Language>(
    ChatJoinReq_Language_descriptor(), name, value);
}
enum ChatJoinRes_Result : int {
  ChatJoinRes_Result_kSuccess = 0,
  ChatJoinRes_Result_kError = 1,
  ChatJoinRes_Result_ChatJoinRes_Result_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ChatJoinRes_Result_ChatJoinRes_Result_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ChatJoinRes_Result_IsValid(int value);
constexpr ChatJoinRes_Result ChatJoinRes_Result_Result_MIN = ChatJoinRes_Result_kSuccess;
constexpr ChatJoinRes_Result ChatJoinRes_Result_Result_MAX = ChatJoinRes_Result_kError;
constexpr int ChatJoinRes_Result_Result_ARRAYSIZE = ChatJoinRes_Result_Result_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ChatJoinRes_Result_descriptor();
template<typename T>
inline const std::string& ChatJoinRes_Result_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ChatJoinRes_Result>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ChatJoinRes_Result_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ChatJoinRes_Result_descriptor(), enum_t_value);
}
inline bool ChatJoinRes_Result_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ChatJoinRes_Result* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ChatJoinRes_Result>(
    ChatJoinRes_Result_descriptor(), name, value);
}
enum GuildMemberType : int {
  Master = 0,
  SubMaster = 1,
  Member = 2,
  GuildMemberType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  GuildMemberType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool GuildMemberType_IsValid(int value);
constexpr GuildMemberType GuildMemberType_MIN = Master;
constexpr GuildMemberType GuildMemberType_MAX = Member;
constexpr int GuildMemberType_ARRAYSIZE = GuildMemberType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* GuildMemberType_descriptor();
template<typename T>
inline const std::string& GuildMemberType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, GuildMemberType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function GuildMemberType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    GuildMemberType_descriptor(), enum_t_value);
}
inline bool GuildMemberType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, GuildMemberType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<GuildMemberType>(
    GuildMemberType_descriptor(), name, value);
}
// ===================================================================

class PingReq final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:chat.PingReq) */ {
 public:
  inline PingReq() : PingReq(nullptr) {}
  explicit PROTOBUF_CONSTEXPR PingReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PingReq(const PingReq& from);
  PingReq(PingReq&& from) noexcept
    : PingReq() {
    *this = ::std::move(from);
  }

  inline PingReq& operator=(const PingReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline PingReq& operator=(PingReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PingReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const PingReq* internal_default_instance() {
    return reinterpret_cast<const PingReq*>(
               &_PingReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(PingReq& a, PingReq& b) {
    a.Swap(&b);
  }
  inline void Swap(PingReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PingReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PingReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PingReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const PingReq& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const PingReq& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chat.PingReq";
  }
  protected:
  explicit PingReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:chat.PingReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_chatting_2eproto;
};
// -------------------------------------------------------------------

class PingRes final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:chat.PingRes) */ {
 public:
  inline PingRes() : PingRes(nullptr) {}
  explicit PROTOBUF_CONSTEXPR PingRes(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PingRes(const PingRes& from);
  PingRes(PingRes&& from) noexcept
    : PingRes() {
    *this = ::std::move(from);
  }

  inline PingRes& operator=(const PingRes& from) {
    CopyFrom(from);
    return *this;
  }
  inline PingRes& operator=(PingRes&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PingRes& default_instance() {
    return *internal_default_instance();
  }
  static inline const PingRes* internal_default_instance() {
    return reinterpret_cast<const PingRes*>(
               &_PingRes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(PingRes& a, PingRes& b) {
    a.Swap(&b);
  }
  inline void Swap(PingRes* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PingRes* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PingRes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PingRes>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const PingRes& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const PingRes& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chat.PingRes";
  }
  protected:
  explicit PingRes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:chat.PingRes)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_chatting_2eproto;
};
// -------------------------------------------------------------------

class LoginReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:chat.LoginReq) */ {
 public:
  inline LoginReq() : LoginReq(nullptr) {}
  ~LoginReq() override;
  explicit PROTOBUF_CONSTEXPR LoginReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoginReq(const LoginReq& from);
  LoginReq(LoginReq&& from) noexcept
    : LoginReq() {
    *this = ::std::move(from);
  }

  inline LoginReq& operator=(const LoginReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoginReq& operator=(LoginReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoginReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoginReq* internal_default_instance() {
    return reinterpret_cast<const LoginReq*>(
               &_LoginReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(LoginReq& a, LoginReq& b) {
    a.Swap(&b);
  }
  inline void Swap(LoginReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoginReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoginReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoginReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LoginReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LoginReq& from) {
    LoginReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoginReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chat.LoginReq";
  }
  protected:
  explicit LoginReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNicknameFieldNumber = 2,
    kUserUidFieldNumber = 1,
  };
  // string nickname = 2;
  void clear_nickname();
  const std::string& nickname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_nickname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_nickname();
  PROTOBUF_NODISCARD std::string* release_nickname();
  void set_allocated_nickname(std::string* nickname);
  private:
  const std::string& _internal_nickname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nickname(const std::string& value);
  std::string* _internal_mutable_nickname();
  public:

  // uint64 user_uid = 1;
  void clear_user_uid();
  uint64_t user_uid() const;
  void set_user_uid(uint64_t value);
  private:
  uint64_t _internal_user_uid() const;
  void _internal_set_user_uid(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:chat.LoginReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr nickname_;
    uint64_t user_uid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chatting_2eproto;
};
// -------------------------------------------------------------------

class LoginRes final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:chat.LoginRes) */ {
 public:
  inline LoginRes() : LoginRes(nullptr) {}
  explicit PROTOBUF_CONSTEXPR LoginRes(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoginRes(const LoginRes& from);
  LoginRes(LoginRes&& from) noexcept
    : LoginRes() {
    *this = ::std::move(from);
  }

  inline LoginRes& operator=(const LoginRes& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoginRes& operator=(LoginRes&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoginRes& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoginRes* internal_default_instance() {
    return reinterpret_cast<const LoginRes*>(
               &_LoginRes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(LoginRes& a, LoginRes& b) {
    a.Swap(&b);
  }
  inline void Swap(LoginRes* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoginRes* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoginRes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoginRes>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const LoginRes& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const LoginRes& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chat.LoginRes";
  }
  protected:
  explicit LoginRes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:chat.LoginRes)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_chatting_2eproto;
};
// -------------------------------------------------------------------

class PetInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:chat.PetInfo) */ {
 public:
  inline PetInfo() : PetInfo(nullptr) {}
  ~PetInfo() override;
  explicit PROTOBUF_CONSTEXPR PetInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PetInfo(const PetInfo& from);
  PetInfo(PetInfo&& from) noexcept
    : PetInfo() {
    *this = ::std::move(from);
  }

  inline PetInfo& operator=(const PetInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline PetInfo& operator=(PetInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PetInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const PetInfo* internal_default_instance() {
    return reinterpret_cast<const PetInfo*>(
               &_PetInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(PetInfo& a, PetInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(PetInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PetInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PetInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PetInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PetInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PetInfo& from) {
    PetInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PetInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chat.PetInfo";
  }
  protected:
  explicit PetInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPetTypeFieldNumber = 1,
    kLevelFieldNumber = 2,
  };
  // int32 pet_type = 1;
  void clear_pet_type();
  int32_t pet_type() const;
  void set_pet_type(int32_t value);
  private:
  int32_t _internal_pet_type() const;
  void _internal_set_pet_type(int32_t value);
  public:

  // int32 level = 2;
  void clear_level();
  int32_t level() const;
  void set_level(int32_t value);
  private:
  int32_t _internal_level() const;
  void _internal_set_level(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:chat.PetInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t pet_type_;
    int32_t level_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chatting_2eproto;
};
// -------------------------------------------------------------------

class ChatMsgInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:chat.ChatMsgInfo) */ {
 public:
  inline ChatMsgInfo() : ChatMsgInfo(nullptr) {}
  ~ChatMsgInfo() override;
  explicit PROTOBUF_CONSTEXPR ChatMsgInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChatMsgInfo(const ChatMsgInfo& from);
  ChatMsgInfo(ChatMsgInfo&& from) noexcept
    : ChatMsgInfo() {
    *this = ::std::move(from);
  }

  inline ChatMsgInfo& operator=(const ChatMsgInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChatMsgInfo& operator=(ChatMsgInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChatMsgInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChatMsgInfo* internal_default_instance() {
    return reinterpret_cast<const ChatMsgInfo*>(
               &_ChatMsgInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ChatMsgInfo& a, ChatMsgInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(ChatMsgInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChatMsgInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChatMsgInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChatMsgInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ChatMsgInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ChatMsgInfo& from) {
    ChatMsgInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChatMsgInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chat.ChatMsgInfo";
  }
  protected:
  explicit ChatMsgInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ChatMsgInfo_AdminType AdminType;
  static constexpr AdminType User =
    ChatMsgInfo_AdminType_User;
  static constexpr AdminType QA =
    ChatMsgInfo_AdminType_QA;
  static constexpr AdminType Admin =
    ChatMsgInfo_AdminType_Admin;
  static inline bool AdminType_IsValid(int value) {
    return ChatMsgInfo_AdminType_IsValid(value);
  }
  static constexpr AdminType AdminType_MIN =
    ChatMsgInfo_AdminType_AdminType_MIN;
  static constexpr AdminType AdminType_MAX =
    ChatMsgInfo_AdminType_AdminType_MAX;
  static constexpr int AdminType_ARRAYSIZE =
    ChatMsgInfo_AdminType_AdminType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  AdminType_descriptor() {
    return ChatMsgInfo_AdminType_descriptor();
  }
  template<typename T>
  static inline const std::string& AdminType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, AdminType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function AdminType_Name.");
    return ChatMsgInfo_AdminType_Name(enum_t_value);
  }
  static inline bool AdminType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      AdminType* value) {
    return ChatMsgInfo_AdminType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kMsgFieldNumber = 1,
    kGuildInfoFieldNumber = 8,
    kPetInfoFieldNumber = 7,
    kWeaponGradeFieldNumber = 2,
    kRankingFieldNumber = 3,
    kCostumeTypeFieldNumber = 4,
    kCostumeLevelFieldNumber = 5,
    kAdminTypeFieldNumber = 6,
  };
  // string msg = 1;
  void clear_msg();
  const std::string& msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg();
  PROTOBUF_NODISCARD std::string* release_msg();
  void set_allocated_msg(std::string* msg);
  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(const std::string& value);
  std::string* _internal_mutable_msg();
  public:

  // string guild_info = 8;
  void clear_guild_info();
  const std::string& guild_info() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_guild_info(ArgT0&& arg0, ArgT... args);
  std::string* mutable_guild_info();
  PROTOBUF_NODISCARD std::string* release_guild_info();
  void set_allocated_guild_info(std::string* guild_info);
  private:
  const std::string& _internal_guild_info() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_guild_info(const std::string& value);
  std::string* _internal_mutable_guild_info();
  public:

  // .chat.PetInfo pet_info = 7;
  bool has_pet_info() const;
  private:
  bool _internal_has_pet_info() const;
  public:
  void clear_pet_info();
  const ::chat::PetInfo& pet_info() const;
  PROTOBUF_NODISCARD ::chat::PetInfo* release_pet_info();
  ::chat::PetInfo* mutable_pet_info();
  void set_allocated_pet_info(::chat::PetInfo* pet_info);
  private:
  const ::chat::PetInfo& _internal_pet_info() const;
  ::chat::PetInfo* _internal_mutable_pet_info();
  public:
  void unsafe_arena_set_allocated_pet_info(
      ::chat::PetInfo* pet_info);
  ::chat::PetInfo* unsafe_arena_release_pet_info();

  // int32 weapon_grade = 2;
  void clear_weapon_grade();
  int32_t weapon_grade() const;
  void set_weapon_grade(int32_t value);
  private:
  int32_t _internal_weapon_grade() const;
  void _internal_set_weapon_grade(int32_t value);
  public:

  // int32 ranking = 3;
  void clear_ranking();
  int32_t ranking() const;
  void set_ranking(int32_t value);
  private:
  int32_t _internal_ranking() const;
  void _internal_set_ranking(int32_t value);
  public:

  // int32 costume_type = 4;
  void clear_costume_type();
  int32_t costume_type() const;
  void set_costume_type(int32_t value);
  private:
  int32_t _internal_costume_type() const;
  void _internal_set_costume_type(int32_t value);
  public:

  // int32 costume_level = 5;
  void clear_costume_level();
  int32_t costume_level() const;
  void set_costume_level(int32_t value);
  private:
  int32_t _internal_costume_level() const;
  void _internal_set_costume_level(int32_t value);
  public:

  // .chat.ChatMsgInfo.AdminType admin_type = 6;
  void clear_admin_type();
  ::chat::ChatMsgInfo_AdminType admin_type() const;
  void set_admin_type(::chat::ChatMsgInfo_AdminType value);
  private:
  ::chat::ChatMsgInfo_AdminType _internal_admin_type() const;
  void _internal_set_admin_type(::chat::ChatMsgInfo_AdminType value);
  public:

  // @@protoc_insertion_point(class_scope:chat.ChatMsgInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr guild_info_;
    ::chat::PetInfo* pet_info_;
    int32_t weapon_grade_;
    int32_t ranking_;
    int32_t costume_type_;
    int32_t costume_level_;
    int admin_type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chatting_2eproto;
};
// -------------------------------------------------------------------

class NicknameChatMsgInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:chat.NicknameChatMsgInfo) */ {
 public:
  inline NicknameChatMsgInfo() : NicknameChatMsgInfo(nullptr) {}
  ~NicknameChatMsgInfo() override;
  explicit PROTOBUF_CONSTEXPR NicknameChatMsgInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NicknameChatMsgInfo(const NicknameChatMsgInfo& from);
  NicknameChatMsgInfo(NicknameChatMsgInfo&& from) noexcept
    : NicknameChatMsgInfo() {
    *this = ::std::move(from);
  }

  inline NicknameChatMsgInfo& operator=(const NicknameChatMsgInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline NicknameChatMsgInfo& operator=(NicknameChatMsgInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NicknameChatMsgInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const NicknameChatMsgInfo* internal_default_instance() {
    return reinterpret_cast<const NicknameChatMsgInfo*>(
               &_NicknameChatMsgInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(NicknameChatMsgInfo& a, NicknameChatMsgInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(NicknameChatMsgInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NicknameChatMsgInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NicknameChatMsgInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NicknameChatMsgInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NicknameChatMsgInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NicknameChatMsgInfo& from) {
    NicknameChatMsgInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NicknameChatMsgInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chat.NicknameChatMsgInfo";
  }
  protected:
  explicit NicknameChatMsgInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNicknameFieldNumber = 1,
    kMsgInfoFieldNumber = 2,
  };
  // string nickname = 1;
  void clear_nickname();
  const std::string& nickname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_nickname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_nickname();
  PROTOBUF_NODISCARD std::string* release_nickname();
  void set_allocated_nickname(std::string* nickname);
  private:
  const std::string& _internal_nickname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nickname(const std::string& value);
  std::string* _internal_mutable_nickname();
  public:

  // .chat.ChatMsgInfo msg_info = 2;
  bool has_msg_info() const;
  private:
  bool _internal_has_msg_info() const;
  public:
  void clear_msg_info();
  const ::chat::ChatMsgInfo& msg_info() const;
  PROTOBUF_NODISCARD ::chat::ChatMsgInfo* release_msg_info();
  ::chat::ChatMsgInfo* mutable_msg_info();
  void set_allocated_msg_info(::chat::ChatMsgInfo* msg_info);
  private:
  const ::chat::ChatMsgInfo& _internal_msg_info() const;
  ::chat::ChatMsgInfo* _internal_mutable_msg_info();
  public:
  void unsafe_arena_set_allocated_msg_info(
      ::chat::ChatMsgInfo* msg_info);
  ::chat::ChatMsgInfo* unsafe_arena_release_msg_info();

  // @@protoc_insertion_point(class_scope:chat.NicknameChatMsgInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr nickname_;
    ::chat::ChatMsgInfo* msg_info_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chatting_2eproto;
};
// -------------------------------------------------------------------

class GuildNicknameChatMsgInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:chat.GuildNicknameChatMsgInfo) */ {
 public:
  inline GuildNicknameChatMsgInfo() : GuildNicknameChatMsgInfo(nullptr) {}
  ~GuildNicknameChatMsgInfo() override;
  explicit PROTOBUF_CONSTEXPR GuildNicknameChatMsgInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GuildNicknameChatMsgInfo(const GuildNicknameChatMsgInfo& from);
  GuildNicknameChatMsgInfo(GuildNicknameChatMsgInfo&& from) noexcept
    : GuildNicknameChatMsgInfo() {
    *this = ::std::move(from);
  }

  inline GuildNicknameChatMsgInfo& operator=(const GuildNicknameChatMsgInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline GuildNicknameChatMsgInfo& operator=(GuildNicknameChatMsgInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GuildNicknameChatMsgInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const GuildNicknameChatMsgInfo* internal_default_instance() {
    return reinterpret_cast<const GuildNicknameChatMsgInfo*>(
               &_GuildNicknameChatMsgInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(GuildNicknameChatMsgInfo& a, GuildNicknameChatMsgInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(GuildNicknameChatMsgInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GuildNicknameChatMsgInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GuildNicknameChatMsgInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GuildNicknameChatMsgInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GuildNicknameChatMsgInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GuildNicknameChatMsgInfo& from) {
    GuildNicknameChatMsgInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GuildNicknameChatMsgInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chat.GuildNicknameChatMsgInfo";
  }
  protected:
  explicit GuildNicknameChatMsgInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNicknameFieldNumber = 1,
    kMsgInfoFieldNumber = 2,
  };
  // string nickname = 1;
  void clear_nickname();
  const std::string& nickname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_nickname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_nickname();
  PROTOBUF_NODISCARD std::string* release_nickname();
  void set_allocated_nickname(std::string* nickname);
  private:
  const std::string& _internal_nickname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nickname(const std::string& value);
  std::string* _internal_mutable_nickname();
  public:

  // .chat.ChatMsgInfo msg_info = 2;
  bool has_msg_info() const;
  private:
  bool _internal_has_msg_info() const;
  public:
  void clear_msg_info();
  const ::chat::ChatMsgInfo& msg_info() const;
  PROTOBUF_NODISCARD ::chat::ChatMsgInfo* release_msg_info();
  ::chat::ChatMsgInfo* mutable_msg_info();
  void set_allocated_msg_info(::chat::ChatMsgInfo* msg_info);
  private:
  const ::chat::ChatMsgInfo& _internal_msg_info() const;
  ::chat::ChatMsgInfo* _internal_mutable_msg_info();
  public:
  void unsafe_arena_set_allocated_msg_info(
      ::chat::ChatMsgInfo* msg_info);
  ::chat::ChatMsgInfo* unsafe_arena_release_msg_info();

  // @@protoc_insertion_point(class_scope:chat.GuildNicknameChatMsgInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr nickname_;
    ::chat::ChatMsgInfo* msg_info_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chatting_2eproto;
};
// -------------------------------------------------------------------

class ChatJoinReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:chat.ChatJoinReq) */ {
 public:
  inline ChatJoinReq() : ChatJoinReq(nullptr) {}
  ~ChatJoinReq() override;
  explicit PROTOBUF_CONSTEXPR ChatJoinReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChatJoinReq(const ChatJoinReq& from);
  ChatJoinReq(ChatJoinReq&& from) noexcept
    : ChatJoinReq() {
    *this = ::std::move(from);
  }

  inline ChatJoinReq& operator=(const ChatJoinReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChatJoinReq& operator=(ChatJoinReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChatJoinReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChatJoinReq* internal_default_instance() {
    return reinterpret_cast<const ChatJoinReq*>(
               &_ChatJoinReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(ChatJoinReq& a, ChatJoinReq& b) {
    a.Swap(&b);
  }
  inline void Swap(ChatJoinReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChatJoinReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChatJoinReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChatJoinReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ChatJoinReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ChatJoinReq& from) {
    ChatJoinReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChatJoinReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chat.ChatJoinReq";
  }
  protected:
  explicit ChatJoinReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ChatJoinReq_Language Language;
  static constexpr Language kKorean =
    ChatJoinReq_Language_kKorean;
  static constexpr Language kEnglish =
    ChatJoinReq_Language_kEnglish;
  static constexpr Language kFrench =
    ChatJoinReq_Language_kFrench;
  static constexpr Language kDeutsch =
    ChatJoinReq_Language_kDeutsch;
  static constexpr Language kJapanese =
    ChatJoinReq_Language_kJapanese;
  static constexpr Language kThai =
    ChatJoinReq_Language_kThai;
  static constexpr Language kChinesesSimple =
    ChatJoinReq_Language_kChinesesSimple;
  static constexpr Language kChinesesTraditional =
    ChatJoinReq_Language_kChinesesTraditional;
  static inline bool Language_IsValid(int value) {
    return ChatJoinReq_Language_IsValid(value);
  }
  static constexpr Language Language_MIN =
    ChatJoinReq_Language_Language_MIN;
  static constexpr Language Language_MAX =
    ChatJoinReq_Language_Language_MAX;
  static constexpr int Language_ARRAYSIZE =
    ChatJoinReq_Language_Language_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Language_descriptor() {
    return ChatJoinReq_Language_descriptor();
  }
  template<typename T>
  static inline const std::string& Language_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Language>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Language_Name.");
    return ChatJoinReq_Language_Name(enum_t_value);
  }
  static inline bool Language_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Language* value) {
    return ChatJoinReq_Language_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kLanguageFieldNumber = 1,
  };
  // .chat.ChatJoinReq.Language language = 1;
  void clear_language();
  ::chat::ChatJoinReq_Language language() const;
  void set_language(::chat::ChatJoinReq_Language value);
  private:
  ::chat::ChatJoinReq_Language _internal_language() const;
  void _internal_set_language(::chat::ChatJoinReq_Language value);
  public:

  // @@protoc_insertion_point(class_scope:chat.ChatJoinReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int language_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chatting_2eproto;
};
// -------------------------------------------------------------------

class ChatJoinRes final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:chat.ChatJoinRes) */ {
 public:
  inline ChatJoinRes() : ChatJoinRes(nullptr) {}
  ~ChatJoinRes() override;
  explicit PROTOBUF_CONSTEXPR ChatJoinRes(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChatJoinRes(const ChatJoinRes& from);
  ChatJoinRes(ChatJoinRes&& from) noexcept
    : ChatJoinRes() {
    *this = ::std::move(from);
  }

  inline ChatJoinRes& operator=(const ChatJoinRes& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChatJoinRes& operator=(ChatJoinRes&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChatJoinRes& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChatJoinRes* internal_default_instance() {
    return reinterpret_cast<const ChatJoinRes*>(
               &_ChatJoinRes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(ChatJoinRes& a, ChatJoinRes& b) {
    a.Swap(&b);
  }
  inline void Swap(ChatJoinRes* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChatJoinRes* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChatJoinRes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChatJoinRes>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ChatJoinRes& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ChatJoinRes& from) {
    ChatJoinRes::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChatJoinRes* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chat.ChatJoinRes";
  }
  protected:
  explicit ChatJoinRes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ChatJoinRes_Result Result;
  static constexpr Result kSuccess =
    ChatJoinRes_Result_kSuccess;
  static constexpr Result kError =
    ChatJoinRes_Result_kError;
  static inline bool Result_IsValid(int value) {
    return ChatJoinRes_Result_IsValid(value);
  }
  static constexpr Result Result_MIN =
    ChatJoinRes_Result_Result_MIN;
  static constexpr Result Result_MAX =
    ChatJoinRes_Result_Result_MAX;
  static constexpr int Result_ARRAYSIZE =
    ChatJoinRes_Result_Result_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Result_descriptor() {
    return ChatJoinRes_Result_descriptor();
  }
  template<typename T>
  static inline const std::string& Result_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Result>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Result_Name.");
    return ChatJoinRes_Result_Name(enum_t_value);
  }
  static inline bool Result_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Result* value) {
    return ChatJoinRes_Result_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kResultFieldNumber = 1,
    kRoomIdFieldNumber = 2,
  };
  // .chat.ChatJoinRes.Result result = 1;
  void clear_result();
  ::chat::ChatJoinRes_Result result() const;
  void set_result(::chat::ChatJoinRes_Result value);
  private:
  ::chat::ChatJoinRes_Result _internal_result() const;
  void _internal_set_result(::chat::ChatJoinRes_Result value);
  public:

  // int32 room_id = 2;
  void clear_room_id();
  int32_t room_id() const;
  void set_room_id(int32_t value);
  private:
  int32_t _internal_room_id() const;
  void _internal_set_room_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:chat.ChatJoinRes)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int result_;
    int32_t room_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chatting_2eproto;
};
// -------------------------------------------------------------------

class ChatBroadcastReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:chat.ChatBroadcastReq) */ {
 public:
  inline ChatBroadcastReq() : ChatBroadcastReq(nullptr) {}
  ~ChatBroadcastReq() override;
  explicit PROTOBUF_CONSTEXPR ChatBroadcastReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChatBroadcastReq(const ChatBroadcastReq& from);
  ChatBroadcastReq(ChatBroadcastReq&& from) noexcept
    : ChatBroadcastReq() {
    *this = ::std::move(from);
  }

  inline ChatBroadcastReq& operator=(const ChatBroadcastReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChatBroadcastReq& operator=(ChatBroadcastReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChatBroadcastReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChatBroadcastReq* internal_default_instance() {
    return reinterpret_cast<const ChatBroadcastReq*>(
               &_ChatBroadcastReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(ChatBroadcastReq& a, ChatBroadcastReq& b) {
    a.Swap(&b);
  }
  inline void Swap(ChatBroadcastReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChatBroadcastReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChatBroadcastReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChatBroadcastReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ChatBroadcastReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ChatBroadcastReq& from) {
    ChatBroadcastReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChatBroadcastReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chat.ChatBroadcastReq";
  }
  protected:
  explicit ChatBroadcastReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChatMsgInfoFieldNumber = 1,
  };
  // .chat.ChatMsgInfo chat_msg_info = 1;
  bool has_chat_msg_info() const;
  private:
  bool _internal_has_chat_msg_info() const;
  public:
  void clear_chat_msg_info();
  const ::chat::ChatMsgInfo& chat_msg_info() const;
  PROTOBUF_NODISCARD ::chat::ChatMsgInfo* release_chat_msg_info();
  ::chat::ChatMsgInfo* mutable_chat_msg_info();
  void set_allocated_chat_msg_info(::chat::ChatMsgInfo* chat_msg_info);
  private:
  const ::chat::ChatMsgInfo& _internal_chat_msg_info() const;
  ::chat::ChatMsgInfo* _internal_mutable_chat_msg_info();
  public:
  void unsafe_arena_set_allocated_chat_msg_info(
      ::chat::ChatMsgInfo* chat_msg_info);
  ::chat::ChatMsgInfo* unsafe_arena_release_chat_msg_info();

  // @@protoc_insertion_point(class_scope:chat.ChatBroadcastReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::chat::ChatMsgInfo* chat_msg_info_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chatting_2eproto;
};
// -------------------------------------------------------------------

class ChatBroadcastNoti final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:chat.ChatBroadcastNoti) */ {
 public:
  inline ChatBroadcastNoti() : ChatBroadcastNoti(nullptr) {}
  ~ChatBroadcastNoti() override;
  explicit PROTOBUF_CONSTEXPR ChatBroadcastNoti(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChatBroadcastNoti(const ChatBroadcastNoti& from);
  ChatBroadcastNoti(ChatBroadcastNoti&& from) noexcept
    : ChatBroadcastNoti() {
    *this = ::std::move(from);
  }

  inline ChatBroadcastNoti& operator=(const ChatBroadcastNoti& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChatBroadcastNoti& operator=(ChatBroadcastNoti&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChatBroadcastNoti& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChatBroadcastNoti* internal_default_instance() {
    return reinterpret_cast<const ChatBroadcastNoti*>(
               &_ChatBroadcastNoti_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(ChatBroadcastNoti& a, ChatBroadcastNoti& b) {
    a.Swap(&b);
  }
  inline void Swap(ChatBroadcastNoti* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChatBroadcastNoti* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChatBroadcastNoti* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChatBroadcastNoti>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ChatBroadcastNoti& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ChatBroadcastNoti& from) {
    ChatBroadcastNoti::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChatBroadcastNoti* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chat.ChatBroadcastNoti";
  }
  protected:
  explicit ChatBroadcastNoti(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNicknameMsgInfoFieldNumber = 1,
  };
  // .chat.NicknameChatMsgInfo nickname_msg_info = 1;
  bool has_nickname_msg_info() const;
  private:
  bool _internal_has_nickname_msg_info() const;
  public:
  void clear_nickname_msg_info();
  const ::chat::NicknameChatMsgInfo& nickname_msg_info() const;
  PROTOBUF_NODISCARD ::chat::NicknameChatMsgInfo* release_nickname_msg_info();
  ::chat::NicknameChatMsgInfo* mutable_nickname_msg_info();
  void set_allocated_nickname_msg_info(::chat::NicknameChatMsgInfo* nickname_msg_info);
  private:
  const ::chat::NicknameChatMsgInfo& _internal_nickname_msg_info() const;
  ::chat::NicknameChatMsgInfo* _internal_mutable_nickname_msg_info();
  public:
  void unsafe_arena_set_allocated_nickname_msg_info(
      ::chat::NicknameChatMsgInfo* nickname_msg_info);
  ::chat::NicknameChatMsgInfo* unsafe_arena_release_nickname_msg_info();

  // @@protoc_insertion_point(class_scope:chat.ChatBroadcastNoti)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::chat::NicknameChatMsgInfo* nickname_msg_info_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chatting_2eproto;
};
// -------------------------------------------------------------------

class ChatHistoryReq final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:chat.ChatHistoryReq) */ {
 public:
  inline ChatHistoryReq() : ChatHistoryReq(nullptr) {}
  explicit PROTOBUF_CONSTEXPR ChatHistoryReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChatHistoryReq(const ChatHistoryReq& from);
  ChatHistoryReq(ChatHistoryReq&& from) noexcept
    : ChatHistoryReq() {
    *this = ::std::move(from);
  }

  inline ChatHistoryReq& operator=(const ChatHistoryReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChatHistoryReq& operator=(ChatHistoryReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChatHistoryReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChatHistoryReq* internal_default_instance() {
    return reinterpret_cast<const ChatHistoryReq*>(
               &_ChatHistoryReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(ChatHistoryReq& a, ChatHistoryReq& b) {
    a.Swap(&b);
  }
  inline void Swap(ChatHistoryReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChatHistoryReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChatHistoryReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChatHistoryReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ChatHistoryReq& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ChatHistoryReq& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chat.ChatHistoryReq";
  }
  protected:
  explicit ChatHistoryReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:chat.ChatHistoryReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_chatting_2eproto;
};
// -------------------------------------------------------------------

class ChatHistoryRes final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:chat.ChatHistoryRes) */ {
 public:
  inline ChatHistoryRes() : ChatHistoryRes(nullptr) {}
  ~ChatHistoryRes() override;
  explicit PROTOBUF_CONSTEXPR ChatHistoryRes(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChatHistoryRes(const ChatHistoryRes& from);
  ChatHistoryRes(ChatHistoryRes&& from) noexcept
    : ChatHistoryRes() {
    *this = ::std::move(from);
  }

  inline ChatHistoryRes& operator=(const ChatHistoryRes& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChatHistoryRes& operator=(ChatHistoryRes&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChatHistoryRes& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChatHistoryRes* internal_default_instance() {
    return reinterpret_cast<const ChatHistoryRes*>(
               &_ChatHistoryRes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(ChatHistoryRes& a, ChatHistoryRes& b) {
    a.Swap(&b);
  }
  inline void Swap(ChatHistoryRes* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChatHistoryRes* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChatHistoryRes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChatHistoryRes>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ChatHistoryRes& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ChatHistoryRes& from) {
    ChatHistoryRes::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChatHistoryRes* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chat.ChatHistoryRes";
  }
  protected:
  explicit ChatHistoryRes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNicknameMsgInfosFieldNumber = 1,
  };
  // repeated .chat.NicknameChatMsgInfo nickname_msg_infos = 1;
  int nickname_msg_infos_size() const;
  private:
  int _internal_nickname_msg_infos_size() const;
  public:
  void clear_nickname_msg_infos();
  ::chat::NicknameChatMsgInfo* mutable_nickname_msg_infos(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::chat::NicknameChatMsgInfo >*
      mutable_nickname_msg_infos();
  private:
  const ::chat::NicknameChatMsgInfo& _internal_nickname_msg_infos(int index) const;
  ::chat::NicknameChatMsgInfo* _internal_add_nickname_msg_infos();
  public:
  const ::chat::NicknameChatMsgInfo& nickname_msg_infos(int index) const;
  ::chat::NicknameChatMsgInfo* add_nickname_msg_infos();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::chat::NicknameChatMsgInfo >&
      nickname_msg_infos() const;

  // @@protoc_insertion_point(class_scope:chat.ChatHistoryRes)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::chat::NicknameChatMsgInfo > nickname_msg_infos_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chatting_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// PingReq

// -------------------------------------------------------------------

// PingRes

// -------------------------------------------------------------------

// LoginReq

// uint64 user_uid = 1;
inline void LoginReq::clear_user_uid() {
  _impl_.user_uid_ = uint64_t{0u};
}
inline uint64_t LoginReq::_internal_user_uid() const {
  return _impl_.user_uid_;
}
inline uint64_t LoginReq::user_uid() const {
  // @@protoc_insertion_point(field_get:chat.LoginReq.user_uid)
  return _internal_user_uid();
}
inline void LoginReq::_internal_set_user_uid(uint64_t value) {
  
  _impl_.user_uid_ = value;
}
inline void LoginReq::set_user_uid(uint64_t value) {
  _internal_set_user_uid(value);
  // @@protoc_insertion_point(field_set:chat.LoginReq.user_uid)
}

// string nickname = 2;
inline void LoginReq::clear_nickname() {
  _impl_.nickname_.ClearToEmpty();
}
inline const std::string& LoginReq::nickname() const {
  // @@protoc_insertion_point(field_get:chat.LoginReq.nickname)
  return _internal_nickname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoginReq::set_nickname(ArgT0&& arg0, ArgT... args) {
 
 _impl_.nickname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chat.LoginReq.nickname)
}
inline std::string* LoginReq::mutable_nickname() {
  std::string* _s = _internal_mutable_nickname();
  // @@protoc_insertion_point(field_mutable:chat.LoginReq.nickname)
  return _s;
}
inline const std::string& LoginReq::_internal_nickname() const {
  return _impl_.nickname_.Get();
}
inline void LoginReq::_internal_set_nickname(const std::string& value) {
  
  _impl_.nickname_.Set(value, GetArenaForAllocation());
}
inline std::string* LoginReq::_internal_mutable_nickname() {
  
  return _impl_.nickname_.Mutable(GetArenaForAllocation());
}
inline std::string* LoginReq::release_nickname() {
  // @@protoc_insertion_point(field_release:chat.LoginReq.nickname)
  return _impl_.nickname_.Release();
}
inline void LoginReq::set_allocated_nickname(std::string* nickname) {
  if (nickname != nullptr) {
    
  } else {
    
  }
  _impl_.nickname_.SetAllocated(nickname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.nickname_.IsDefault()) {
    _impl_.nickname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chat.LoginReq.nickname)
}

// -------------------------------------------------------------------

// LoginRes

// -------------------------------------------------------------------

// PetInfo

// int32 pet_type = 1;
inline void PetInfo::clear_pet_type() {
  _impl_.pet_type_ = 0;
}
inline int32_t PetInfo::_internal_pet_type() const {
  return _impl_.pet_type_;
}
inline int32_t PetInfo::pet_type() const {
  // @@protoc_insertion_point(field_get:chat.PetInfo.pet_type)
  return _internal_pet_type();
}
inline void PetInfo::_internal_set_pet_type(int32_t value) {
  
  _impl_.pet_type_ = value;
}
inline void PetInfo::set_pet_type(int32_t value) {
  _internal_set_pet_type(value);
  // @@protoc_insertion_point(field_set:chat.PetInfo.pet_type)
}

// int32 level = 2;
inline void PetInfo::clear_level() {
  _impl_.level_ = 0;
}
inline int32_t PetInfo::_internal_level() const {
  return _impl_.level_;
}
inline int32_t PetInfo::level() const {
  // @@protoc_insertion_point(field_get:chat.PetInfo.level)
  return _internal_level();
}
inline void PetInfo::_internal_set_level(int32_t value) {
  
  _impl_.level_ = value;
}
inline void PetInfo::set_level(int32_t value) {
  _internal_set_level(value);
  // @@protoc_insertion_point(field_set:chat.PetInfo.level)
}

// -------------------------------------------------------------------

// ChatMsgInfo

// string msg = 1;
inline void ChatMsgInfo::clear_msg() {
  _impl_.msg_.ClearToEmpty();
}
inline const std::string& ChatMsgInfo::msg() const {
  // @@protoc_insertion_point(field_get:chat.ChatMsgInfo.msg)
  return _internal_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChatMsgInfo::set_msg(ArgT0&& arg0, ArgT... args) {
 
 _impl_.msg_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chat.ChatMsgInfo.msg)
}
inline std::string* ChatMsgInfo::mutable_msg() {
  std::string* _s = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:chat.ChatMsgInfo.msg)
  return _s;
}
inline const std::string& ChatMsgInfo::_internal_msg() const {
  return _impl_.msg_.Get();
}
inline void ChatMsgInfo::_internal_set_msg(const std::string& value) {
  
  _impl_.msg_.Set(value, GetArenaForAllocation());
}
inline std::string* ChatMsgInfo::_internal_mutable_msg() {
  
  return _impl_.msg_.Mutable(GetArenaForAllocation());
}
inline std::string* ChatMsgInfo::release_msg() {
  // @@protoc_insertion_point(field_release:chat.ChatMsgInfo.msg)
  return _impl_.msg_.Release();
}
inline void ChatMsgInfo::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    
  } else {
    
  }
  _impl_.msg_.SetAllocated(msg, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.msg_.IsDefault()) {
    _impl_.msg_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chat.ChatMsgInfo.msg)
}

// int32 weapon_grade = 2;
inline void ChatMsgInfo::clear_weapon_grade() {
  _impl_.weapon_grade_ = 0;
}
inline int32_t ChatMsgInfo::_internal_weapon_grade() const {
  return _impl_.weapon_grade_;
}
inline int32_t ChatMsgInfo::weapon_grade() const {
  // @@protoc_insertion_point(field_get:chat.ChatMsgInfo.weapon_grade)
  return _internal_weapon_grade();
}
inline void ChatMsgInfo::_internal_set_weapon_grade(int32_t value) {
  
  _impl_.weapon_grade_ = value;
}
inline void ChatMsgInfo::set_weapon_grade(int32_t value) {
  _internal_set_weapon_grade(value);
  // @@protoc_insertion_point(field_set:chat.ChatMsgInfo.weapon_grade)
}

// int32 ranking = 3;
inline void ChatMsgInfo::clear_ranking() {
  _impl_.ranking_ = 0;
}
inline int32_t ChatMsgInfo::_internal_ranking() const {
  return _impl_.ranking_;
}
inline int32_t ChatMsgInfo::ranking() const {
  // @@protoc_insertion_point(field_get:chat.ChatMsgInfo.ranking)
  return _internal_ranking();
}
inline void ChatMsgInfo::_internal_set_ranking(int32_t value) {
  
  _impl_.ranking_ = value;
}
inline void ChatMsgInfo::set_ranking(int32_t value) {
  _internal_set_ranking(value);
  // @@protoc_insertion_point(field_set:chat.ChatMsgInfo.ranking)
}

// int32 costume_type = 4;
inline void ChatMsgInfo::clear_costume_type() {
  _impl_.costume_type_ = 0;
}
inline int32_t ChatMsgInfo::_internal_costume_type() const {
  return _impl_.costume_type_;
}
inline int32_t ChatMsgInfo::costume_type() const {
  // @@protoc_insertion_point(field_get:chat.ChatMsgInfo.costume_type)
  return _internal_costume_type();
}
inline void ChatMsgInfo::_internal_set_costume_type(int32_t value) {
  
  _impl_.costume_type_ = value;
}
inline void ChatMsgInfo::set_costume_type(int32_t value) {
  _internal_set_costume_type(value);
  // @@protoc_insertion_point(field_set:chat.ChatMsgInfo.costume_type)
}

// int32 costume_level = 5;
inline void ChatMsgInfo::clear_costume_level() {
  _impl_.costume_level_ = 0;
}
inline int32_t ChatMsgInfo::_internal_costume_level() const {
  return _impl_.costume_level_;
}
inline int32_t ChatMsgInfo::costume_level() const {
  // @@protoc_insertion_point(field_get:chat.ChatMsgInfo.costume_level)
  return _internal_costume_level();
}
inline void ChatMsgInfo::_internal_set_costume_level(int32_t value) {
  
  _impl_.costume_level_ = value;
}
inline void ChatMsgInfo::set_costume_level(int32_t value) {
  _internal_set_costume_level(value);
  // @@protoc_insertion_point(field_set:chat.ChatMsgInfo.costume_level)
}

// .chat.ChatMsgInfo.AdminType admin_type = 6;
inline void ChatMsgInfo::clear_admin_type() {
  _impl_.admin_type_ = 0;
}
inline ::chat::ChatMsgInfo_AdminType ChatMsgInfo::_internal_admin_type() const {
  return static_cast< ::chat::ChatMsgInfo_AdminType >(_impl_.admin_type_);
}
inline ::chat::ChatMsgInfo_AdminType ChatMsgInfo::admin_type() const {
  // @@protoc_insertion_point(field_get:chat.ChatMsgInfo.admin_type)
  return _internal_admin_type();
}
inline void ChatMsgInfo::_internal_set_admin_type(::chat::ChatMsgInfo_AdminType value) {
  
  _impl_.admin_type_ = value;
}
inline void ChatMsgInfo::set_admin_type(::chat::ChatMsgInfo_AdminType value) {
  _internal_set_admin_type(value);
  // @@protoc_insertion_point(field_set:chat.ChatMsgInfo.admin_type)
}

// .chat.PetInfo pet_info = 7;
inline bool ChatMsgInfo::_internal_has_pet_info() const {
  return this != internal_default_instance() && _impl_.pet_info_ != nullptr;
}
inline bool ChatMsgInfo::has_pet_info() const {
  return _internal_has_pet_info();
}
inline void ChatMsgInfo::clear_pet_info() {
  if (GetArenaForAllocation() == nullptr && _impl_.pet_info_ != nullptr) {
    delete _impl_.pet_info_;
  }
  _impl_.pet_info_ = nullptr;
}
inline const ::chat::PetInfo& ChatMsgInfo::_internal_pet_info() const {
  const ::chat::PetInfo* p = _impl_.pet_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::chat::PetInfo&>(
      ::chat::_PetInfo_default_instance_);
}
inline const ::chat::PetInfo& ChatMsgInfo::pet_info() const {
  // @@protoc_insertion_point(field_get:chat.ChatMsgInfo.pet_info)
  return _internal_pet_info();
}
inline void ChatMsgInfo::unsafe_arena_set_allocated_pet_info(
    ::chat::PetInfo* pet_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pet_info_);
  }
  _impl_.pet_info_ = pet_info;
  if (pet_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:chat.ChatMsgInfo.pet_info)
}
inline ::chat::PetInfo* ChatMsgInfo::release_pet_info() {
  
  ::chat::PetInfo* temp = _impl_.pet_info_;
  _impl_.pet_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::chat::PetInfo* ChatMsgInfo::unsafe_arena_release_pet_info() {
  // @@protoc_insertion_point(field_release:chat.ChatMsgInfo.pet_info)
  
  ::chat::PetInfo* temp = _impl_.pet_info_;
  _impl_.pet_info_ = nullptr;
  return temp;
}
inline ::chat::PetInfo* ChatMsgInfo::_internal_mutable_pet_info() {
  
  if (_impl_.pet_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::chat::PetInfo>(GetArenaForAllocation());
    _impl_.pet_info_ = p;
  }
  return _impl_.pet_info_;
}
inline ::chat::PetInfo* ChatMsgInfo::mutable_pet_info() {
  ::chat::PetInfo* _msg = _internal_mutable_pet_info();
  // @@protoc_insertion_point(field_mutable:chat.ChatMsgInfo.pet_info)
  return _msg;
}
inline void ChatMsgInfo::set_allocated_pet_info(::chat::PetInfo* pet_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.pet_info_;
  }
  if (pet_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(pet_info);
    if (message_arena != submessage_arena) {
      pet_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pet_info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.pet_info_ = pet_info;
  // @@protoc_insertion_point(field_set_allocated:chat.ChatMsgInfo.pet_info)
}

// string guild_info = 8;
inline void ChatMsgInfo::clear_guild_info() {
  _impl_.guild_info_.ClearToEmpty();
}
inline const std::string& ChatMsgInfo::guild_info() const {
  // @@protoc_insertion_point(field_get:chat.ChatMsgInfo.guild_info)
  return _internal_guild_info();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChatMsgInfo::set_guild_info(ArgT0&& arg0, ArgT... args) {
 
 _impl_.guild_info_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chat.ChatMsgInfo.guild_info)
}
inline std::string* ChatMsgInfo::mutable_guild_info() {
  std::string* _s = _internal_mutable_guild_info();
  // @@protoc_insertion_point(field_mutable:chat.ChatMsgInfo.guild_info)
  return _s;
}
inline const std::string& ChatMsgInfo::_internal_guild_info() const {
  return _impl_.guild_info_.Get();
}
inline void ChatMsgInfo::_internal_set_guild_info(const std::string& value) {
  
  _impl_.guild_info_.Set(value, GetArenaForAllocation());
}
inline std::string* ChatMsgInfo::_internal_mutable_guild_info() {
  
  return _impl_.guild_info_.Mutable(GetArenaForAllocation());
}
inline std::string* ChatMsgInfo::release_guild_info() {
  // @@protoc_insertion_point(field_release:chat.ChatMsgInfo.guild_info)
  return _impl_.guild_info_.Release();
}
inline void ChatMsgInfo::set_allocated_guild_info(std::string* guild_info) {
  if (guild_info != nullptr) {
    
  } else {
    
  }
  _impl_.guild_info_.SetAllocated(guild_info, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.guild_info_.IsDefault()) {
    _impl_.guild_info_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chat.ChatMsgInfo.guild_info)
}

// -------------------------------------------------------------------

// NicknameChatMsgInfo

// string nickname = 1;
inline void NicknameChatMsgInfo::clear_nickname() {
  _impl_.nickname_.ClearToEmpty();
}
inline const std::string& NicknameChatMsgInfo::nickname() const {
  // @@protoc_insertion_point(field_get:chat.NicknameChatMsgInfo.nickname)
  return _internal_nickname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NicknameChatMsgInfo::set_nickname(ArgT0&& arg0, ArgT... args) {
 
 _impl_.nickname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chat.NicknameChatMsgInfo.nickname)
}
inline std::string* NicknameChatMsgInfo::mutable_nickname() {
  std::string* _s = _internal_mutable_nickname();
  // @@protoc_insertion_point(field_mutable:chat.NicknameChatMsgInfo.nickname)
  return _s;
}
inline const std::string& NicknameChatMsgInfo::_internal_nickname() const {
  return _impl_.nickname_.Get();
}
inline void NicknameChatMsgInfo::_internal_set_nickname(const std::string& value) {
  
  _impl_.nickname_.Set(value, GetArenaForAllocation());
}
inline std::string* NicknameChatMsgInfo::_internal_mutable_nickname() {
  
  return _impl_.nickname_.Mutable(GetArenaForAllocation());
}
inline std::string* NicknameChatMsgInfo::release_nickname() {
  // @@protoc_insertion_point(field_release:chat.NicknameChatMsgInfo.nickname)
  return _impl_.nickname_.Release();
}
inline void NicknameChatMsgInfo::set_allocated_nickname(std::string* nickname) {
  if (nickname != nullptr) {
    
  } else {
    
  }
  _impl_.nickname_.SetAllocated(nickname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.nickname_.IsDefault()) {
    _impl_.nickname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chat.NicknameChatMsgInfo.nickname)
}

// .chat.ChatMsgInfo msg_info = 2;
inline bool NicknameChatMsgInfo::_internal_has_msg_info() const {
  return this != internal_default_instance() && _impl_.msg_info_ != nullptr;
}
inline bool NicknameChatMsgInfo::has_msg_info() const {
  return _internal_has_msg_info();
}
inline void NicknameChatMsgInfo::clear_msg_info() {
  if (GetArenaForAllocation() == nullptr && _impl_.msg_info_ != nullptr) {
    delete _impl_.msg_info_;
  }
  _impl_.msg_info_ = nullptr;
}
inline const ::chat::ChatMsgInfo& NicknameChatMsgInfo::_internal_msg_info() const {
  const ::chat::ChatMsgInfo* p = _impl_.msg_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::chat::ChatMsgInfo&>(
      ::chat::_ChatMsgInfo_default_instance_);
}
inline const ::chat::ChatMsgInfo& NicknameChatMsgInfo::msg_info() const {
  // @@protoc_insertion_point(field_get:chat.NicknameChatMsgInfo.msg_info)
  return _internal_msg_info();
}
inline void NicknameChatMsgInfo::unsafe_arena_set_allocated_msg_info(
    ::chat::ChatMsgInfo* msg_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.msg_info_);
  }
  _impl_.msg_info_ = msg_info;
  if (msg_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:chat.NicknameChatMsgInfo.msg_info)
}
inline ::chat::ChatMsgInfo* NicknameChatMsgInfo::release_msg_info() {
  
  ::chat::ChatMsgInfo* temp = _impl_.msg_info_;
  _impl_.msg_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::chat::ChatMsgInfo* NicknameChatMsgInfo::unsafe_arena_release_msg_info() {
  // @@protoc_insertion_point(field_release:chat.NicknameChatMsgInfo.msg_info)
  
  ::chat::ChatMsgInfo* temp = _impl_.msg_info_;
  _impl_.msg_info_ = nullptr;
  return temp;
}
inline ::chat::ChatMsgInfo* NicknameChatMsgInfo::_internal_mutable_msg_info() {
  
  if (_impl_.msg_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::chat::ChatMsgInfo>(GetArenaForAllocation());
    _impl_.msg_info_ = p;
  }
  return _impl_.msg_info_;
}
inline ::chat::ChatMsgInfo* NicknameChatMsgInfo::mutable_msg_info() {
  ::chat::ChatMsgInfo* _msg = _internal_mutable_msg_info();
  // @@protoc_insertion_point(field_mutable:chat.NicknameChatMsgInfo.msg_info)
  return _msg;
}
inline void NicknameChatMsgInfo::set_allocated_msg_info(::chat::ChatMsgInfo* msg_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.msg_info_;
  }
  if (msg_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(msg_info);
    if (message_arena != submessage_arena) {
      msg_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, msg_info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.msg_info_ = msg_info;
  // @@protoc_insertion_point(field_set_allocated:chat.NicknameChatMsgInfo.msg_info)
}

// -------------------------------------------------------------------

// GuildNicknameChatMsgInfo

// string nickname = 1;
inline void GuildNicknameChatMsgInfo::clear_nickname() {
  _impl_.nickname_.ClearToEmpty();
}
inline const std::string& GuildNicknameChatMsgInfo::nickname() const {
  // @@protoc_insertion_point(field_get:chat.GuildNicknameChatMsgInfo.nickname)
  return _internal_nickname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GuildNicknameChatMsgInfo::set_nickname(ArgT0&& arg0, ArgT... args) {
 
 _impl_.nickname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chat.GuildNicknameChatMsgInfo.nickname)
}
inline std::string* GuildNicknameChatMsgInfo::mutable_nickname() {
  std::string* _s = _internal_mutable_nickname();
  // @@protoc_insertion_point(field_mutable:chat.GuildNicknameChatMsgInfo.nickname)
  return _s;
}
inline const std::string& GuildNicknameChatMsgInfo::_internal_nickname() const {
  return _impl_.nickname_.Get();
}
inline void GuildNicknameChatMsgInfo::_internal_set_nickname(const std::string& value) {
  
  _impl_.nickname_.Set(value, GetArenaForAllocation());
}
inline std::string* GuildNicknameChatMsgInfo::_internal_mutable_nickname() {
  
  return _impl_.nickname_.Mutable(GetArenaForAllocation());
}
inline std::string* GuildNicknameChatMsgInfo::release_nickname() {
  // @@protoc_insertion_point(field_release:chat.GuildNicknameChatMsgInfo.nickname)
  return _impl_.nickname_.Release();
}
inline void GuildNicknameChatMsgInfo::set_allocated_nickname(std::string* nickname) {
  if (nickname != nullptr) {
    
  } else {
    
  }
  _impl_.nickname_.SetAllocated(nickname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.nickname_.IsDefault()) {
    _impl_.nickname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chat.GuildNicknameChatMsgInfo.nickname)
}

// .chat.ChatMsgInfo msg_info = 2;
inline bool GuildNicknameChatMsgInfo::_internal_has_msg_info() const {
  return this != internal_default_instance() && _impl_.msg_info_ != nullptr;
}
inline bool GuildNicknameChatMsgInfo::has_msg_info() const {
  return _internal_has_msg_info();
}
inline void GuildNicknameChatMsgInfo::clear_msg_info() {
  if (GetArenaForAllocation() == nullptr && _impl_.msg_info_ != nullptr) {
    delete _impl_.msg_info_;
  }
  _impl_.msg_info_ = nullptr;
}
inline const ::chat::ChatMsgInfo& GuildNicknameChatMsgInfo::_internal_msg_info() const {
  const ::chat::ChatMsgInfo* p = _impl_.msg_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::chat::ChatMsgInfo&>(
      ::chat::_ChatMsgInfo_default_instance_);
}
inline const ::chat::ChatMsgInfo& GuildNicknameChatMsgInfo::msg_info() const {
  // @@protoc_insertion_point(field_get:chat.GuildNicknameChatMsgInfo.msg_info)
  return _internal_msg_info();
}
inline void GuildNicknameChatMsgInfo::unsafe_arena_set_allocated_msg_info(
    ::chat::ChatMsgInfo* msg_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.msg_info_);
  }
  _impl_.msg_info_ = msg_info;
  if (msg_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:chat.GuildNicknameChatMsgInfo.msg_info)
}
inline ::chat::ChatMsgInfo* GuildNicknameChatMsgInfo::release_msg_info() {
  
  ::chat::ChatMsgInfo* temp = _impl_.msg_info_;
  _impl_.msg_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::chat::ChatMsgInfo* GuildNicknameChatMsgInfo::unsafe_arena_release_msg_info() {
  // @@protoc_insertion_point(field_release:chat.GuildNicknameChatMsgInfo.msg_info)
  
  ::chat::ChatMsgInfo* temp = _impl_.msg_info_;
  _impl_.msg_info_ = nullptr;
  return temp;
}
inline ::chat::ChatMsgInfo* GuildNicknameChatMsgInfo::_internal_mutable_msg_info() {
  
  if (_impl_.msg_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::chat::ChatMsgInfo>(GetArenaForAllocation());
    _impl_.msg_info_ = p;
  }
  return _impl_.msg_info_;
}
inline ::chat::ChatMsgInfo* GuildNicknameChatMsgInfo::mutable_msg_info() {
  ::chat::ChatMsgInfo* _msg = _internal_mutable_msg_info();
  // @@protoc_insertion_point(field_mutable:chat.GuildNicknameChatMsgInfo.msg_info)
  return _msg;
}
inline void GuildNicknameChatMsgInfo::set_allocated_msg_info(::chat::ChatMsgInfo* msg_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.msg_info_;
  }
  if (msg_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(msg_info);
    if (message_arena != submessage_arena) {
      msg_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, msg_info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.msg_info_ = msg_info;
  // @@protoc_insertion_point(field_set_allocated:chat.GuildNicknameChatMsgInfo.msg_info)
}

// -------------------------------------------------------------------

// ChatJoinReq

// .chat.ChatJoinReq.Language language = 1;
inline void ChatJoinReq::clear_language() {
  _impl_.language_ = 0;
}
inline ::chat::ChatJoinReq_Language ChatJoinReq::_internal_language() const {
  return static_cast< ::chat::ChatJoinReq_Language >(_impl_.language_);
}
inline ::chat::ChatJoinReq_Language ChatJoinReq::language() const {
  // @@protoc_insertion_point(field_get:chat.ChatJoinReq.language)
  return _internal_language();
}
inline void ChatJoinReq::_internal_set_language(::chat::ChatJoinReq_Language value) {
  
  _impl_.language_ = value;
}
inline void ChatJoinReq::set_language(::chat::ChatJoinReq_Language value) {
  _internal_set_language(value);
  // @@protoc_insertion_point(field_set:chat.ChatJoinReq.language)
}

// -------------------------------------------------------------------

// ChatJoinRes

// .chat.ChatJoinRes.Result result = 1;
inline void ChatJoinRes::clear_result() {
  _impl_.result_ = 0;
}
inline ::chat::ChatJoinRes_Result ChatJoinRes::_internal_result() const {
  return static_cast< ::chat::ChatJoinRes_Result >(_impl_.result_);
}
inline ::chat::ChatJoinRes_Result ChatJoinRes::result() const {
  // @@protoc_insertion_point(field_get:chat.ChatJoinRes.result)
  return _internal_result();
}
inline void ChatJoinRes::_internal_set_result(::chat::ChatJoinRes_Result value) {
  
  _impl_.result_ = value;
}
inline void ChatJoinRes::set_result(::chat::ChatJoinRes_Result value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:chat.ChatJoinRes.result)
}

// int32 room_id = 2;
inline void ChatJoinRes::clear_room_id() {
  _impl_.room_id_ = 0;
}
inline int32_t ChatJoinRes::_internal_room_id() const {
  return _impl_.room_id_;
}
inline int32_t ChatJoinRes::room_id() const {
  // @@protoc_insertion_point(field_get:chat.ChatJoinRes.room_id)
  return _internal_room_id();
}
inline void ChatJoinRes::_internal_set_room_id(int32_t value) {
  
  _impl_.room_id_ = value;
}
inline void ChatJoinRes::set_room_id(int32_t value) {
  _internal_set_room_id(value);
  // @@protoc_insertion_point(field_set:chat.ChatJoinRes.room_id)
}

// -------------------------------------------------------------------

// ChatBroadcastReq

// .chat.ChatMsgInfo chat_msg_info = 1;
inline bool ChatBroadcastReq::_internal_has_chat_msg_info() const {
  return this != internal_default_instance() && _impl_.chat_msg_info_ != nullptr;
}
inline bool ChatBroadcastReq::has_chat_msg_info() const {
  return _internal_has_chat_msg_info();
}
inline void ChatBroadcastReq::clear_chat_msg_info() {
  if (GetArenaForAllocation() == nullptr && _impl_.chat_msg_info_ != nullptr) {
    delete _impl_.chat_msg_info_;
  }
  _impl_.chat_msg_info_ = nullptr;
}
inline const ::chat::ChatMsgInfo& ChatBroadcastReq::_internal_chat_msg_info() const {
  const ::chat::ChatMsgInfo* p = _impl_.chat_msg_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::chat::ChatMsgInfo&>(
      ::chat::_ChatMsgInfo_default_instance_);
}
inline const ::chat::ChatMsgInfo& ChatBroadcastReq::chat_msg_info() const {
  // @@protoc_insertion_point(field_get:chat.ChatBroadcastReq.chat_msg_info)
  return _internal_chat_msg_info();
}
inline void ChatBroadcastReq::unsafe_arena_set_allocated_chat_msg_info(
    ::chat::ChatMsgInfo* chat_msg_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.chat_msg_info_);
  }
  _impl_.chat_msg_info_ = chat_msg_info;
  if (chat_msg_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:chat.ChatBroadcastReq.chat_msg_info)
}
inline ::chat::ChatMsgInfo* ChatBroadcastReq::release_chat_msg_info() {
  
  ::chat::ChatMsgInfo* temp = _impl_.chat_msg_info_;
  _impl_.chat_msg_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::chat::ChatMsgInfo* ChatBroadcastReq::unsafe_arena_release_chat_msg_info() {
  // @@protoc_insertion_point(field_release:chat.ChatBroadcastReq.chat_msg_info)
  
  ::chat::ChatMsgInfo* temp = _impl_.chat_msg_info_;
  _impl_.chat_msg_info_ = nullptr;
  return temp;
}
inline ::chat::ChatMsgInfo* ChatBroadcastReq::_internal_mutable_chat_msg_info() {
  
  if (_impl_.chat_msg_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::chat::ChatMsgInfo>(GetArenaForAllocation());
    _impl_.chat_msg_info_ = p;
  }
  return _impl_.chat_msg_info_;
}
inline ::chat::ChatMsgInfo* ChatBroadcastReq::mutable_chat_msg_info() {
  ::chat::ChatMsgInfo* _msg = _internal_mutable_chat_msg_info();
  // @@protoc_insertion_point(field_mutable:chat.ChatBroadcastReq.chat_msg_info)
  return _msg;
}
inline void ChatBroadcastReq::set_allocated_chat_msg_info(::chat::ChatMsgInfo* chat_msg_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.chat_msg_info_;
  }
  if (chat_msg_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(chat_msg_info);
    if (message_arena != submessage_arena) {
      chat_msg_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, chat_msg_info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.chat_msg_info_ = chat_msg_info;
  // @@protoc_insertion_point(field_set_allocated:chat.ChatBroadcastReq.chat_msg_info)
}

// -------------------------------------------------------------------

// ChatBroadcastNoti

// .chat.NicknameChatMsgInfo nickname_msg_info = 1;
inline bool ChatBroadcastNoti::_internal_has_nickname_msg_info() const {
  return this != internal_default_instance() && _impl_.nickname_msg_info_ != nullptr;
}
inline bool ChatBroadcastNoti::has_nickname_msg_info() const {
  return _internal_has_nickname_msg_info();
}
inline void ChatBroadcastNoti::clear_nickname_msg_info() {
  if (GetArenaForAllocation() == nullptr && _impl_.nickname_msg_info_ != nullptr) {
    delete _impl_.nickname_msg_info_;
  }
  _impl_.nickname_msg_info_ = nullptr;
}
inline const ::chat::NicknameChatMsgInfo& ChatBroadcastNoti::_internal_nickname_msg_info() const {
  const ::chat::NicknameChatMsgInfo* p = _impl_.nickname_msg_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::chat::NicknameChatMsgInfo&>(
      ::chat::_NicknameChatMsgInfo_default_instance_);
}
inline const ::chat::NicknameChatMsgInfo& ChatBroadcastNoti::nickname_msg_info() const {
  // @@protoc_insertion_point(field_get:chat.ChatBroadcastNoti.nickname_msg_info)
  return _internal_nickname_msg_info();
}
inline void ChatBroadcastNoti::unsafe_arena_set_allocated_nickname_msg_info(
    ::chat::NicknameChatMsgInfo* nickname_msg_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.nickname_msg_info_);
  }
  _impl_.nickname_msg_info_ = nickname_msg_info;
  if (nickname_msg_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:chat.ChatBroadcastNoti.nickname_msg_info)
}
inline ::chat::NicknameChatMsgInfo* ChatBroadcastNoti::release_nickname_msg_info() {
  
  ::chat::NicknameChatMsgInfo* temp = _impl_.nickname_msg_info_;
  _impl_.nickname_msg_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::chat::NicknameChatMsgInfo* ChatBroadcastNoti::unsafe_arena_release_nickname_msg_info() {
  // @@protoc_insertion_point(field_release:chat.ChatBroadcastNoti.nickname_msg_info)
  
  ::chat::NicknameChatMsgInfo* temp = _impl_.nickname_msg_info_;
  _impl_.nickname_msg_info_ = nullptr;
  return temp;
}
inline ::chat::NicknameChatMsgInfo* ChatBroadcastNoti::_internal_mutable_nickname_msg_info() {
  
  if (_impl_.nickname_msg_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::chat::NicknameChatMsgInfo>(GetArenaForAllocation());
    _impl_.nickname_msg_info_ = p;
  }
  return _impl_.nickname_msg_info_;
}
inline ::chat::NicknameChatMsgInfo* ChatBroadcastNoti::mutable_nickname_msg_info() {
  ::chat::NicknameChatMsgInfo* _msg = _internal_mutable_nickname_msg_info();
  // @@protoc_insertion_point(field_mutable:chat.ChatBroadcastNoti.nickname_msg_info)
  return _msg;
}
inline void ChatBroadcastNoti::set_allocated_nickname_msg_info(::chat::NicknameChatMsgInfo* nickname_msg_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.nickname_msg_info_;
  }
  if (nickname_msg_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(nickname_msg_info);
    if (message_arena != submessage_arena) {
      nickname_msg_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, nickname_msg_info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.nickname_msg_info_ = nickname_msg_info;
  // @@protoc_insertion_point(field_set_allocated:chat.ChatBroadcastNoti.nickname_msg_info)
}

// -------------------------------------------------------------------

// ChatHistoryReq

// -------------------------------------------------------------------

// ChatHistoryRes

// repeated .chat.NicknameChatMsgInfo nickname_msg_infos = 1;
inline int ChatHistoryRes::_internal_nickname_msg_infos_size() const {
  return _impl_.nickname_msg_infos_.size();
}
inline int ChatHistoryRes::nickname_msg_infos_size() const {
  return _internal_nickname_msg_infos_size();
}
inline void ChatHistoryRes::clear_nickname_msg_infos() {
  _impl_.nickname_msg_infos_.Clear();
}
inline ::chat::NicknameChatMsgInfo* ChatHistoryRes::mutable_nickname_msg_infos(int index) {
  // @@protoc_insertion_point(field_mutable:chat.ChatHistoryRes.nickname_msg_infos)
  return _impl_.nickname_msg_infos_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::chat::NicknameChatMsgInfo >*
ChatHistoryRes::mutable_nickname_msg_infos() {
  // @@protoc_insertion_point(field_mutable_list:chat.ChatHistoryRes.nickname_msg_infos)
  return &_impl_.nickname_msg_infos_;
}
inline const ::chat::NicknameChatMsgInfo& ChatHistoryRes::_internal_nickname_msg_infos(int index) const {
  return _impl_.nickname_msg_infos_.Get(index);
}
inline const ::chat::NicknameChatMsgInfo& ChatHistoryRes::nickname_msg_infos(int index) const {
  // @@protoc_insertion_point(field_get:chat.ChatHistoryRes.nickname_msg_infos)
  return _internal_nickname_msg_infos(index);
}
inline ::chat::NicknameChatMsgInfo* ChatHistoryRes::_internal_add_nickname_msg_infos() {
  return _impl_.nickname_msg_infos_.Add();
}
inline ::chat::NicknameChatMsgInfo* ChatHistoryRes::add_nickname_msg_infos() {
  ::chat::NicknameChatMsgInfo* _add = _internal_add_nickname_msg_infos();
  // @@protoc_insertion_point(field_add:chat.ChatHistoryRes.nickname_msg_infos)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::chat::NicknameChatMsgInfo >&
ChatHistoryRes::nickname_msg_infos() const {
  // @@protoc_insertion_point(field_list:chat.ChatHistoryRes.nickname_msg_infos)
  return _impl_.nickname_msg_infos_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace chat

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::chat::ChatMsgInfo_AdminType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::chat::ChatMsgInfo_AdminType>() {
  return ::chat::ChatMsgInfo_AdminType_descriptor();
}
template <> struct is_proto_enum< ::chat::ChatJoinReq_Language> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::chat::ChatJoinReq_Language>() {
  return ::chat::ChatJoinReq_Language_descriptor();
}
template <> struct is_proto_enum< ::chat::ChatJoinRes_Result> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::chat::ChatJoinRes_Result>() {
  return ::chat::ChatJoinRes_Result_descriptor();
}
template <> struct is_proto_enum< ::chat::GuildMemberType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::chat::GuildMemberType>() {
  return ::chat::GuildMemberType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_chatting_2eproto
